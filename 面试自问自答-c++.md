# 面试自问自答 - c++



1. const

   > 作用:
   >
   > 1. 修饰变量，说明该变量不可以被改变；
   > 2. 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；
   > 3. 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；
   > 4. **修饰成员函数，说明该成员函数内不能修改成员变量**。

2. static

   > 作用:
   >
   > 1. 修饰普通变量，修改变量的存储区域和生命周期，使**变量存储在静态区，在 main 函数运行前就分配了空间**，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
   > 2. 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。
   > 3. 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。
   > 4. 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 **static 函数内不能访问非静态成员**。

3. this指针

   > this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。
   > 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。
   > this 指针被隐含地声明为: ClassName *const this，这意味着**不能给 this 指针赋值**；*但可以修改指针指向的地址, (指针的本质是一个地址(这个不可修改), 它存的值(*this)也是一个地址,这个可以修改,即修改指向)
   >
   > this 并不是一个常规变量，而是个右值，所以**不能取得 this 的地址**（不能 &this）。
   >
   > *在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；
   >
   > 在以下场景中，经常需要显式引用 this 指针：
   > 为实现对象的链式引用；
   > 为避免对同一对象进行赋值操作；
   > 在实现一些数据结构时，如 list

4. inline内联函数

   > 优点:
   >
   > 速度快: 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。
   > 安全: 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。
   > 可访问成员变量: 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。
   > 内联函数在运行时可调试，而宏定义不可以。
   >
   > 
   >
   > 缺点:
   >
   > 代码膨胀: 内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
   > inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
   > 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。

   虚函数可以被inline修饰, 但虚函数想用多态的话不能inline

5. volatile 不稳定的

   > 变量可被编译器未知原因修改, 每次取值都直接从内存取

6. assert

   > 断言, false则中断程序

7. "#pragma pack(n)"

   > 主要作用: 改变编译器的内存对齐方式,网络报文的处理中很重要
   >
   > 默认n=8, 可取1,2,4,8,16(字节)

8. extern “C”

   > extern "C" 的作用是让 C++ 编译器将 extern "C" 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。
   >
   > 和#ifdef #endif一起使用

9. 多态分类及实现

   > 重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载
   > 子类型多态（Subtype Polymorphism，运行期）：虚函数
   > 参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板
   > 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换

10. 虚函数

    > 普通函数（非类成员函数）不能是虚函数;
    > 静态函数（static）不能是虚函数;
    > 构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）;
    > 内联函数不能是表现多态性时的虚函数

11. 虚析构函数
	
	> 虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。
	
12. 

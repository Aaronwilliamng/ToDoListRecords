# 面试自问自答 - c++



1. const

   > 作用:
   >
   > 1. 修饰变量，说明该变量不可以被改变；
   > 2. 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；
   > 3. 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；
   > 4. **修饰成员函数，说明该成员函数内不能修改成员变量**。

2. static

   > 作用:
   >
   > 1. 修饰普通变量，修改变量的存储区域和生命周期，使**变量存储在静态区，在 main 函数运行前就分配了空间**，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
   > 2. 修饰普通函数，表明函数的作用范围，仅在**定义该函数的文件内才能使用。在多人开发项目时**，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。
   > 3. 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。
   > 4. 修饰成员函数，**没有this指针**, 修饰成员函数使得不需要生成对象就可以访问该函数，但是在 **static 函数内不能访问非静态成员**。

3. this指针

   > this 指针是一个隐含于每一个**非静态**成员函数中的指针, 指向对象的地址。
   >
   > 要点:
   >
   > 1. **不能给 this 指针赋值**: this 指针被隐含地声明为: ClassName *const this；*
   > 2. 在调用成员函数时，编译器会隐含地插入一个参数，即this指针。this指针指向当前对象本身，表示当前对象的地址。
   > 3. this 是一个右值，所以**不能取得 this 的地址**（不能 &this）。
   >
   > *在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；
   >
   > 在以下场景中，经常需要显式引用 this 指针：
   > 为实现对象的链式引用；
   > 为避免对同一对象进行赋值操作；
   > 在实现一些数据结构时，如 list

4. 右值

   > 一般说法: 可以取地址的、有名字的是左值;反之，不能取地址、没有名字的是右值。
   >
   > 分为纯右值、将亡值
   >
   > 纯右值: **临时变量**(1+3) 或 **跟对象无关**(‘c', 2, true)
   >
   > 将亡值: c++11新增的 跟**右值引用相关**的表达式
   
5. 右值引用 &&

   > 必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值
   > ```c++
   > class Sub{}
   > Sub GetInstance(){
   > return Sub();
   > }
   > int main(){
   > Sub a=GetInstance();
   > ```
   >
   > 3个过程: 
   >
   > GetInstance()调用Sub()构造一次, 得到临时变量, 结束时析构; 
   >
   > 返回的临时变量传给返回值: 调用一次复制构造函数; 
   >
   > main函数中a赋值调用复制构造函数
   >
   > 作用:
   >
   > 延长临时变量的生存时间, 避免拷贝, 提高性能

6. inline内联函数

   > 优点:
   >
   > 速度快: 内联函数同宏函数一样将在编译时在被调用处进行代码展开，**省去了参数压栈、栈帧开辟与回收，结果返回等**，从而提高程序运行速度。
   > 安全: 内联函数相比宏函数来说，在**代码展开时，会做安全检查或自动类型转换**（同普通函数），而宏定义则不会。
   > 可访问成员变量: 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。
   > 内联函数在运行时可调试，而宏定义不可以。
   >
   > 
   >
   > 缺点:
   >
   > 代码膨胀: 内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。
   >
   > 另一方面，**每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间**。
   > inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
   > 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。

   虚函数可以被inline修饰, 但虚函数想用多态的话不能inline

7. c++的内存

   > 1. 栈：是由编译器在需要时**自动分配**，不需要时**自动清除**的变量存储区。通常存放**局部变量、函数参数**等。
   >
   > 2. 堆：是由**new**分配的内存块，**由程序员释放**（编译器不管），一般一个new与一个delete对应，一个new[]与一个delete[]对应。如果程序员没有释放掉, 资源将由操作系统**在程序结束后自动回收**。
   >
   > 3. 自由存储区：是由**malloc**等分配的内存块，和堆十分相似，用**free**来释放。
   >
   > 4. **全局/静态**存储区：全局变量和静态变量被分配到同一块内存中
   >
   > 5. **常量**存储区：这是一块特殊存储区，里边存放常量，不允许修改。
   >
   > （注意：堆和自由存储区其实不过是同一块区域，new底层实现代码中调用了malloc，new可以看成是malloc智能化的高级版本）

8. 内存中堆和栈的区别

   >1. 分配方式：
   >   1. 堆都是动态分配（没有静态分配的堆）;
   >   2. 栈有静态分配和动态分配，静态分配由编译器完成（如局部变量分配）, 动态分配由alloca函数分配, 但栈的动态分配的资源由编译器进行释放，无需程序员实现。
   >
   >2. 生长方向
   >   1. 堆向上增长; 栈向下

9. new和malloc

   > 1. 参数:
   > 2. malloc是从**堆上**动态分配内存，new是从**自由存储区**为对象动态分配内存。 
   > 3. new申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。
   >    2. malloc则需显式指出内存的尺寸。
   > 4. 功能
   >    1. new：分配内存 和 调用构造函数; delete：调用析构函数 和 释放内存
   >    2. malloc和free: 只是分配和释放内存
   >  5. 返回:
   >     1. new内存分配失败时，会抛出bad_alloc异常;
   >     2. malloc分配内存失败时返回NULL。
   >

10. malloc实现

   > malloc 函数的实质是它有一个将可用的内存块连接为一个长长的列表的所谓**空闲链表**。 调用 malloc（）函数时，它沿着连接表寻找一个大到足以满足用户请求所需要的内存块。 然后，**将该内存块切分**（一块的大小与用户申请的大小相等，另一块的大小就是剩下来的字节）。 接下来，将分配给用户的那块内存存储区域传给用户，并将剩下的那块（如果有的话）返回到**连接表**上; 没有的话, 会**请求延时**。 调用 free 函数时，它将用户释放的内存块连接到空闲链表上; 

11. 内存分配和管理 malloc、calloc、realloc、alloca

   > malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。
   > calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位都初始化为 0。
   > realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。
   > alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。

12. new、delete

    > new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。
    > delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。
    > new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。

13. 如何定义一个只能在堆上（栈上）生成对象的类？

    > 只能在堆上
    >
    > 方法：将析构函数设置为私有
    >
    > 原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。**若析构函数不可访问，则不能在栈上创建对象**。
    >
    > 
    >
    > 只能在栈上
    >
    > 方法：将 new 和 delete 重载为私有
    >
    > 原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。**将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象**。

14. allocator类

15. 必须要用初始化列表

    > 1. 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面
    > 2. 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面
    > 3. 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化

16. 数组与链表

   > 数组
   >
   > 元素在内存中连续存放，每个元素占用内存相同，可通过下标迅速访问数组中任何元素; 
   >
   > 增删开销大
   >
   > **(静态)数组从栈中分配空间**, 对于程序员方便快速,但自由度小。 
   >
   > 
   >
   > 链表
   >
   > 通过指针连接起来
   >
   > 需要时可以**用new分配内存空间，不需要时用delete将已分配的空间释放**
   >
   > 链表从堆中分配空间, 自由度大但申请管理比较麻烦. 

17. 深拷贝 浅拷贝

    > 浅拷贝: 在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的；但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，所以，此时，必须采用深拷贝。
    > 深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。

18. 函数调用的过程

    > 整个函数的调用总结起来就干了四件事情：
    >
    > 第一：将调用方的栈底地址入栈。====》push  ebp
    >
    > 第二：让原本指向调用方**栈底的ebp指向当前函数的栈底**。====》mov   ebp,esp
    >
    > 第三：给当前函数**开辟栈帧** (通过**栈底指针偏移将局部变量压入栈桢空间**)====>sub   esp,44h
    >
    > 第四：对开辟的栈帧进行初始化。初始化的大小不一定。====>rep   stos  
    >
    > 
    >
    > 例子:
    >
    >     void func(int m, int n) {
    >     int a, b;
    >     a = m;
    >     b = n;
    >     }
    >     main() {
    >     ...
    >     func(m, n);
    >     L:  下一条语句;
    >     }
    >
    > main调用func前:
    >
    > ```
    > ebp //main函数栈帧底部
    > ...
    > esp	//当前栈顶
    > ```
    >
    > 调用func时(写成汇编):
    >
    > ```
    > push m
    > push n; 两个参数压入栈
    > call func; 调用func，将返回地址（实际上是当前PC值的下一个值, 即L）填入栈，并跳转到func
    > ```
    >
    > 当成功跳转到func函数中时，func函数的栈帧就已经形成了，但是形成新的栈帧之前，必须要重新记录当前栈帧的栈底指针ebp，保存和切换ebp
    >
    > ```
    > push ebp; 
    > /*函数调用之所以能够返回，单靠保持返回地址是不够的，这一步压栈动作很重要，因为我们要标记函数调用者栈帧的帧底，这样才能找出保存了的返回地址，栈顶是不用保存的，因为上一个栈帧的顶部讲会是func的栈帧底部。（两栈帧相邻的）*/
    > mov ebp, esp; 上一栈帧的顶部，就是这个栈帧的底部
    > sub esp, 8   ;  int a, b 这里声明了两个int，所以esp减小8个字节来为a,b分配空间
    > mov dword ptr [esp+4], [ebp+12];   a=m
    > mov dword ptr [esp], [ebp+8]; b=n 
    > ```
    >
    > 当从func函数返回时:
    >
    > ```
    > esp移动到栈帧底部（即释放自动变量）
    > 上一个函数的栈帧底部指针弹出到ebp，再弹出返回地址到cs:ip上，
    > esp继续移动划过参数
    > 这样，ebp,esp就回到了调用函数前的状态，即现在恢复了原来的main的栈帧。
    > ```

19. main函数执行前做了什么

    > 1. **操作系统创建进程**后，把**控制权交给程序的入口函数**, 往往是运行时库的某个入口函数。 
    >
    > 2. 入口函数对运行库和程序运行环境进行**初始化**，包括**堆，I/O，线程，全局变量构造**等。
    > 3. 调用main函数，正式开始执行程序主体。
    > 4. 执行main完毕，返回入口函数，进行清理工作，包括全局变量析构，堆销毁，关闭I/O等，然后进行系统调用结束进程

20. volatile 不稳定的

    > 变量可被编译器未知原因修改, 每次取值都直接从内存取

21. assert

    > 断言, false则中断程序

22. "#pragma pack(n)"

    > 主要作用: 改变编译器的内存对齐方式,网络报文的处理中很重要
    >
    > 默认n=8, 可取1,2,4,8,16(字节)
    >
    > gcc默认=4, vs默认为8
    >
    > ```c++
    > #pragma pack(4)
    > class test1{
    >   char c='1';//1byte 
    >     int i;//4byte
    >     short s=2;//2byte
    > };
    > 
    > class test2 {
    >     int i;//4byte
    >     char c = '1';//1byte 
    >     short s = 2;//2byte
    > };
    > sizeof(test1)为12; sizeof(test2)为8
    >   
    > // 因为c(占用1,对齐为4)即 c(1 0 0 0) i(1 1 1 1) s(1 1) 类本身对齐(0 0)
    > // c直接分配1字节, 然后i需要4, 只有3字节,不够,所以此时才空3格, 重新分配4字节
    > ```

23. 内存对齐

    > C++空类的内存大小为1字节
    >
    > 非空类的大小与类中非静态成员变量和虚函数表的多少有关。
    >
    > 而类中非静态成员变量的大小与编译器内存对齐的设置有关。
    >
    > 成员变量在类中的内存存储并不一定是连续的。它是按照编译器的设置，按照内存块来存储的，这个内存块大小的取值，就是内存对齐。

24. 大端与小端模式

    > 网络字节序: 大端
    >
    > 主机: 大端或小端 看机型(x86(intel, ARM为小端))
    >
    > 文件: PS, JPEG(大端) ; BMP, GIF(小端)
    >
    > 大端、小端的判断:
    >
    > ```c++
    > int i = 0x12345678;
    > if (*((char*)&i) == 0x12) // 第一个字节地址(取址)的内容转为字符数组(char*强制转化)查看(*)
    > 	cout << "大端" << endl;
    > else	
    > 	cout << "小端" << endl;
    > ```

25. extern “C”

   > extern "C" 的作用是让 C++ 编译器将 extern "C" 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。
   >
   > 和#ifdef #endif一起使用

26. 多态分类及实现

    > 重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载
    > 子类型多态（Subtype Polymorphism，运行期）：虚函数
    > 参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板
    > 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换

27. 虚函数

    > 1. 虚函数代价:
    >    1. 虚函数表(当然不用占用类的内存空间)
    >    2. 类的对象需要维护一个虚表指针(4字节)
    >    3. 虚函数不能内联
    > 2. 不能是虚函数的:
    >
    >    1. 普通函数（非类成员函数）不能是虚函数;
    >    2. 友元函数: 不属于类的
    >    3. 静态成员函数（static）不能是虚函数**, 因为静态函数没有this指针, 无法访问对象的虚表指**
    >    4. **构造函数不能是虚函数（因为在调用构造函数时，**虚表指针并没有在对象的内存空间**中，必须要构造函数调用完成后才会形成虚表指针）
    >    5. 内联函数不能是表现多态性时的虚函数, 内敛函数在编译时进行函数题替换, 虚函数表现多态时在运行时决定

28. 虚函数表(虚表) 和 虚函数表指针

    > 为实现C++的多态，C++使用了一种**动态绑定**的技术, 其核心是虚函数表
    >
    > 每个包含了虚函数的类都包含一个虚表
    >
    > **虚表就是一个指针数组**, 里面的指针指向该类虚函数的地址
    >
    > **虚表是属于类不是对象的**, 同类的各对象的虚表指针指向同个虚表  
    >
    > **虚函数表vtable存放在可执行文件的只读数据段.rodata中**
    >
    > 
    >
    > 继承:
    >
    > A类是基类, B继承A
    >
    > A的虚表指向vfunc1() 和 vfunc2(), B如果重写vfunc2(), 则B的虚表指向vfunc1() 和 B::vfunc2()
    >
    > 普通函数(非虚函数)不在虚表中
    >
    > 
    >
    > A* p指向B对象, 然后用p调用vfunc1()的过程:
    >
    > 程序在执行p->vfunc1()时，会发现p是个指针，且调用的函数是虚函数，便会进行以下的步骤:
    > 首先，根据虚表指针p->vptr来**访问对象bObject对应的虚表**。虽然指针p是基类A*类型，但是vptr也是基类的一部分，所以可以通过p->vptr可以访问到对象对应的虚表。 
    > 然后，在虚表中查找所调用的函数对应的条目。由于**虚表在编译阶段就可以构造出来了**，所以可以根据所调用的函数**定位到虚表中的对应条目**。对于 p->vfunc1()的调用，B vtbl的第一项即是vfunc1对应的条目。 
    > 最后，根据虚表中找到的函数指针，调用函数。从图3可以看到，B vtbl的第一项指向B::vfunc1()，所以 p->vfunc1()实质会调用B::vfunc1()函数。
    >
    > 实现了多态(虚函数和对象(指针)的动态绑定)

29. 虚析构函数(结合“虚函数表 和 虚表指针”回答)

   > 虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。

30. 纯虚函数

    > `virtual int A() = 0;`
    >
    > 纯虚函数关注的是接口的统一性，实现由子类完成
    >
    > 带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。

31. 虚继承

    > 虚继承是与虚函数完全无关的一个概念
    >
    > 虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性(子类中存在多份拷贝)）。
    >
    > 一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅**最多存在一份**而已，并不是不在子类里面了）；**当虚继承的子类被当做父类继承时，虚基类指针也会被继承。**
    >
    > vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），**虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员**，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。

32. 抽象类、接口类、聚合类

    > 抽象类：含有纯虚函数的类;
    >
    > 接口类：仅含有纯虚函数的抽象类;
    >
    > 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。
    >
    > 满足如下特点：
    > 	所有成员都是 public
    > 	没有定义任何构造函数
    > 	没有类内初始化
    > 	没有基类，也没有 virtual 函数

33. 智能指针

    > 不恰当处理指针就会带来许多问题, 比如: 指针所指向对象的生命周期, 挂起引用（dangling references）, 内存泄露这些问题。
    >
    > 挂起引用: 一块内存被多个指针引用，但其中的一个指针释放且其余的指针并不知道，这样的情况下，就发生了
    >
    > 内存泄漏: 从堆中申请了内存后不释放回去
    >
    > 
    >
    > C++11以前的智能指针: auto_ptr, 离开作用域会自动释放所致内存地址
    >
    > 缺点: 
    >
    > 1. auto_ptr赋值给另一个auto_ptr, 所有权转移之后, 原来的可能变成野指针
    > 2. 不能指向一组对象, 比如跟new[]一起用
    >
    > 
    >
    > C++11的智能指针: share_ptr, unique_ptr, weak_ptr, 头文件<memory>
    >
    > 1. share_ptr: 多个指针可以同时指向一个对象，当最后一个shared_ptr离开作用域时，内存才会自动释放。
    >
    >    1. 使用一般是`std::auto_ptr<int> ptr1(new int(5)); `不会把原始指针暴露, 只能通过智能指针操作; 而且参数必须是new出来的(从堆来), 不能是静态(在栈上), 因为析构时会delete
    >
    >       ```c++ 
    >       std::shared_ptr<int> ptra = std::make_shared<int>(a);
    >       std::shared_ptr<int> ptra2(ptra); //copy, 引用计数+1
    >       ```
    >
    >    2. 通过计数器+1, 释放指针-1,直到0才释放内存空间; 引用计数是线程安全的，但是对象的读取需要加锁。
    >
    >    3. 智能指针是个模板类，可以指定类型，传入指针通过构造函数初始化。也可以使用make_shared函数初始化。不能将指针直接赋值给一个智能指针，一个是类，一个是指针
    >
    >    4. 隐患:
    >
    >       1. 注意不要用一个原始指针初始化多个shared_ptr，否则会造成二次释放同一内存
    >       2. 注意避免循环引用，shared_ptr的一个最大的陷阱是循环引用, 具体为在shared_ptr中，A，B的引用计数均为2，所以在析构掉pa与pb时，他们的引用计数都没能到达0，于是发生了循环引用，于是开始内存泄露
    >          1. 解决方法: 将类A,B中的一个shared_prt改为weak_ptr即可，weak_ptr不会增加shared_ptr的引用计数
    >
    > 2. unique_ptr: 采用独占式拥有，确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。
    >
    >    1. 通过禁止拷贝语义、只有移动语义来实现
    >
    >       ```c++
    >       std::unique_ptr<int> uptr(new int(10));  //绑定动态对象
    >       std::unique_ptr<int> uptr2 = uptr;  //错误, 不能賦值
    >       std::unique_ptr<int> uptr2(uptr);  //错误, 不能拷貝
    >       
    >       std::unique_ptr<int> uptr2 = std::move(uptr); //轉換所有權
    >       uptr2.release(); //释放所有权
    >       ```
    >
    > 3. weak_ptr: weak_ptr是用来避免循环引用的, 允许你共享但不拥有某对象，weak_ptr不会增加shared_ptr的引用计数, 一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty) 

34. c++11新特性

    > 1. nullptr: 可以被转换成任意其它的指针类型
    > 2. for(auto i : arr )
    > 3. auto, decltype表示智能类型
    > 4. 右值引用
    > 5. 智能指针(share_ptr, unique_ptr, weak_ptr)
    > 6. unordered_map, unordered_set
    > 7. lambda表达式
    > 8. std::thread

35. auto和decltype(type)

    >  都是C++11新增的关键字，都用于自动类型推导
    >
    > auto会去掉引用, decltype会保留引用;
    >
    > decltype可以不初始化, auto必须初始化;

36. stl中的vector和array

    > 区别:
    >
    > array 是静态空间，一旦配置了就不能改变，vector 是动态数组。在 ***堆上*** 分配空间
    >
    > 
    >
    > vector:
    >
    > capacity: end - first; size: last - first
    >
    > `reserve（Count）`: 对应capacity, 预留空间, 防止二次分配
    >
    > `resize(Count)`:对应size
    >
    > capacity扩容按不同库可能会扩大一半或一倍
    >
    > 创建时会配置比其所容纳的元素所需更多的内存, 避免二次分配
    >
    > 扩容: 弃用现有, 申请更大, 移动旧数据, 释放原内存

37. stl中的list

    > STL 中的list 底层是一个双向链表，而且是一个环状双向链表
    >
    > 需要经常添加删除大对象, 可使用 list；
    > 保存的对象不大，构造与析构操作不复杂，那么可以使用 vector 代替。
    > list<指针> 是性能最低的做法，这种情况下还是使用 vector<指针> 好，因为指针没有构造与析构，也不占用很大内存

38. stl中的priority_queue

    > 以vector实现的完全二叉树
    >
    > 堆的要点:
    >
    > 1. 建堆: 左右子树为堆的前提, 大的与当前节点交换, 然后siftdown操作
    > 2. 插入: 放后面, 直接向上交换, 直到停止, 不用siftdown
    > 3. 删除: 把最后一个(完全二叉树的最后一个)置换道要删的, 然后siftdown

39. stl中的set和multi_set

    > 底层为红黑树RB-Tree, 故查到时间复杂度O(log n), 值即键值, 值自动排序

40. stl中的map和multi_map

    > 底层为红黑树RB-Tree, 故查到时间复杂度O(log n)

41. stl中的unordered_map

    > hash_map是非标准库, c++11标准化为了防止误用新的, 将新加的哈希表命名为unordered_map
    >
    > 底层为hash map实现, 相比hash_map可以用string和其他一些复杂类型作为键值

42. lambda表达式

    > ```c++
    > [](){} //匿名函数声明
    > [](){}() //匿名函数调用
    > []中可以有
    >   1. [=]: 值传递, 函数可以使用Lambda作用范围内可见的局部变量
    >   2. [&]: 引用传递, 基本同=
    >   3. this
    >   4. a: a值传递
    >   5. &a: a引用传递
    > ```
    >
    > 

43. 动态内存

44. typeid

45. 强制类型转化cast

    > 1. dynamic_cast: (**检查安全性**) 类类型指针
    >
    >    只用于**对象和引用**，主要用于执行安全的**向下转型**，他可以将指向子类的父类指针转换为子类指针，但是**要求父类有虚函数**，如果转换为指针类型失败则返回`NULL`，如果是引用类型转换失败则跑出`bad_cast`的异常
    >
    > 2. static_cast: (**不检查安全性**, 需要程序员保证合理性)
    >    1. 用于基本数据类型 
    >    2. non_const到const（反过来必须用const_cast)
    >    3. 把空指针转换为目标类型的指针
    >    4. 将任何类型的表达式转换为void类型
    >    5. 可以将子类类型的指针转换为父类类型的指针（这种转换的安全性需要开发人员来保证）
    >
    > 3. const_cast: 消除const
    >
    > 4. reinterpret_cast可以适用于任何类型指针之间的转换, 但不安全
    >
    >    可以在非相关的类型之间转换，操作只是简单的从一个指针到别的指针的值得二进制拷贝，在类型之间指向的内容不作任何类型的检查和转换。

46. Linux相关

    > 1. 通配符
    >
    >    “？”可替代单个字符。 ·“*”可替代任意多个字符。 ·方括号“[charset]”可替代 charset 集中的任何单个字符，如[a-z]，[abABC]
    >
    > 2. ipcs: 进程间通信
    >
    > 3. Gprof: 性能诊断分析, 分析定位性能瓶颈
    >
    > 4. 查看进程状态`ps`，查看cpu状态` top`, 查看占用端口的进程号`netstat grep`
    >
    > 5. kill
    >
    > 6. `netstat`,` tcpdump`,` ipcs` ,`ipcrm` （如果这四个命令没听说过或者不能熟练使用，基本上可以回家，这四个命令的熟练掌握程度基本上能体现面试者实际开发和调试程序的经验)
    >
    > 7. `netstat`
    >
    > 8. `tcpdump`
    >
    > 9. `ipcs`
    >
    > 10. `ipcrm`
    >
    > 11. cpu 内存 硬盘 等等与系统性能调试相关的命令必须熟练掌握，设置修改权限 tcp网络状态查看 各进程状态 抓包相关等相关命令 必须熟练掌握

47. 一个文件从源代码到可执行程序会经历以下4个步骤：

    > .cpp/.c -> .i -> .s -> .o(.lib/.dll/.a/.so) -> 可执行文件
    >
    > 1. 预处理：在程序运行(main函数执行)之前，修改源码，主要处理代码中的#include头文件和#define宏定义代码（将程序运行时用到的#include头文件中的代码和#define宏定义的代码进行替换），最后生成一个.i文件（.i文件里面是替换代码之后的代码文件）
    > 2. 编译：此阶段会**检查代码的规范性、是否有语法错误**等。在检查无误后，把.i代码文件进行编译，然后生成一个汇编语言.s文件（**.s文件里面都是汇编语言**）。此处只进行编译生成汇编代码，而不真正的进行汇编
    > 3. 汇编：此阶段把.s文件翻译成二进制机器指令.o文件。生成的**.o文件是二进制文件**（直接用文本工具打开看到的将是乱码，我们需要反汇编工具如GDB的帮助才能读懂它），Windows下为.obj文件
    > 4. 链接：此阶段会**链接所有的函数、全局变量**，**将所有的.o文件链接成一个可执行文件**（例如hello.c文件调用了printf函数，printf函数存在一个名为printf.o的文件中，而我们必须把printf.o合并到hello.o中）。不过有时.o文件太多，链接会很不方便，所以我们会给**.o文件进行打包生成静/动态库文件**（**Windows下为.lib和.dll文件，Linux下为.a和.so文件**）

48. 静态链接 动态链接

    > 静态链接
    >
    > 预处理->编译->汇编->链接。在链接过程中，如果使用了静态链接库，整个静态库的二进制代码会被复制到生成的可执行文件中, 在程序运行的时候，可以直接从二进制代码中获取库函数的内部细节;
    >
    > 
    >
    > 动态链接
    >
    > 如果使用了动态链接库，则链接这一过程会被推迟到程序运行阶段。在程序运行的时候，如果某一步需要调用动态链接库，则首先在虚拟内存的映射区开辟一块空间，然后通过类似mmap的方法将动态链接库映射到程序的虚拟内存中。因为是代码, 即只读数据，不存在数据竞争问题。

49. 设计模式

    > [CSDN设计模式及实现代码](https://blog.csdn.net/u010993820/article/details/80968933?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase)
    >
    > 1. 单例模式
    >
    >    保证一个类只有一个实例，并提供一个访问它的全局访问点，使得系统中只有唯一的一个对象实例。
    >
    >    ```c++
    >    class Singleton{
    >    public:
    >    static Singleton& getInstance(){
    >    static Singleton instance;
    >    return instance;
    >    }
    >    void printTest(){
    >    cout<<"do something"<<endl;
    >    }
    >    private:
    >    Singleton(){}//防止外部调用构造创建对象, 保证只有唯一一个
    >    Singleton(Singleton const &singleton);//阻止拷贝创建对象
    >    Singleton& operator=(Singleton const &singleton);//阻止赋值对象
    >    };
    >    int main()
    >    {
    >    Singleton &a=Singleton::getInstance();
    >    a.printTest();
    >    return 0;
    >    }
    >    ```
    >
    >    饿汉模式
    >
    >    ```c++
    >    //饿汉模式: 饿汉式单例是指在方法调用前，实例就已经创建好了
    >    package org.mlinge.s01;
    >    public class MySingleton {
    >    	private:
    >      	static MySingleton instance = new MySingleton();//实例先建立
    >    		MySingleton(){};
    >    	public:
    >      	static MySingleton getInstance() {
    >    			return instance;
    >    	}
    >    }
    >    ```
    >
    >    懒汉模式(线程不安全)
    >
    >    ```c++
    >    //懒汉式: 单例是指在方法调用获取实例时才创建实例
    >    package org.mlinge.s02;
    >    public class MySingleton {
    >    	private:
    >      	static MySingleton instance = null;
    >    		MySingleton(){}
    >    	public:
    >      	static MySingleton getInstance() {
    >    			if(instance == null){//懒汉式
    >    				instance = new MySingleton(); //单例是指在方法调用获取实例时才创建实例
    >    			}
    >    		return instance;
    >    	}
    >    }
    >    ```
    >
    >    线程安全的懒汉模式: 使用同步锁机制 `synchronized` 但这种方法效率低
    >
    >    `public synchronized static MySingleton getInstance(){}`
    >
    >    还可以使用 双检查锁机制 Double Check Locking, DCL
    >
    >    
    >
    >    ```c++
    >    //单例模式，手写双重检验单例模式 懒汉式，DCL（8）
    >    
    >    //饿汉式：
    >    public class Singleton{
    >        private static Singleton singleton = new Singleton();
    >        private Singleton(){}
    >        public static Singleton getSingleton(){
    >            return singleton;
    >        }
    >    }
    >     
    >    //懒汉式(线程不安全)：
    >    public class Singleton{
    >        private static Singleton singleton = null;
    >        private Singleton(){}
    >        public static Singleton getSingleton(){
    >            if(singleton == null){
    >                singleton = new Singleton();
    >            }
    >            return singleton;
    >        }
    >    }
    >    
    >    //双重校验单例模式(DCL)：
    >    public class Singleton{
    >        private volatile static Singleton singleton;
    >        private Singleton(){}
    >        public static Singleton getSingleton(){
    >            if(singleton == null){
    >                //类对象加锁
    >                synchronized (Singleton.class) {
    >                    if(singleton == null){
    >                        singleton = new Singleton();
    >                    }
    >                }
    >            }
    >            return singleton;
    >        }
    >    }
    >    ```
    >
    >    
    >
    > 2. 工厂模式
    >
    >    1. 简单工厂模式(工厂类负责生产各产品)
    >    2. 工厂方法模式(各工厂生产对应的产品)
    >    3. 抽象工厂模式(重写生产函数, 同样的产品, 重写分为低端, 高端产品)
    >
    > 一些设计模式问题:
    >
    > 1、 请问你用过哪些设计模式，介绍一下单例模式的多线程安全问题
    >
    > 2 、请问你了解哪些设计模式？
    >
    > 3 、请问如何保证单例模式只有唯一实例？你知道的都有哪些方法？
    >
    > 4 、请你说一说 OOP 的设计模式的五项原则
    >
    > 5 、请你说说工厂模式的优点？
    >
    > 6 、请你说一下观察者模式
    >
    > 7 、请你介绍一下单例模式
    >
    > 8 、单例模式中的懒汉加载，如果并发访问该怎么做
    >
    > 9 、装饰器模式和单例模式，使用单例模式应该注意什么？l
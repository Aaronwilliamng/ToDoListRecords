# 面试自问自答 - c++



1. const

   > 作用:
   >
   > 1. 修饰变量，说明该变量不可以被改变；
   > 2. 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；
   > 3. 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；
   > 4. **修饰成员函数，说明该成员函数内不能修改成员变量**。

2. static

   > 作用:
   >
   > 1. 修饰普通变量，修改变量的存储区域和生命周期，使**变量存储在静态区，在 main 函数运行前就分配了空间**，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
   > 2. 修饰普通函数，表明函数的作用范围，仅在**定义该函数的文件内才能使用。在多人开发项目时**，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。
   > 3. 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。
   > 4. 修饰成员函数，**没有this指针**, 修饰成员函数使得不需要生成对象就可以访问该函数，但是在 **static 函数内不能访问非静态成员**。

3. this指针

   > this 指针是一个隐含于每一个**非静态**成员函数中的指针, 指向对象的地址。
   >
   > 要点:
   >
   > 1. **不能给 this 指针赋值**: this 指针被隐含地声明为: ClassName *const this；*
   > 2. 在调用成员函数时，编译器会隐含地插入一个参数，即this指针。this指针指向当前对象本身，表示当前对象的地址。
   > 3. this 是一个右值，所以**不能取得 this 的地址**（不能 &this）。
   >
   > *在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；
   >
   > 在以下场景中，经常需要显式引用 this 指针：
   > 为实现对象的链式引用；
   > 为避免对同一对象进行赋值操作；
   > 在实现一些数据结构时，如 list

4. 右值

   > 一般说法: 可以取地址的、有名字的是左值;反之，不能取地址、没有名字的是右值。
   >
   > 分为纯右值、将亡值
   >
   > 纯右值: **临时变量**(1+3) 或 **跟对象无关**(‘c', 2, true)
   >
   > 将亡值: c++11新增的 跟**右值引用相关**的表达式

5. 右值引用

   > ```c++
   > class Sub{}
   > Sub GetInstance(){
   > return Sub();
   > }
   > int main(){
   > Sub a=GetInstance();
   > ```
   >
   > 3个过程: 
   >
   > GetInstance()调用Sub()构造一次, 得到临时变量, 结束时析构; 
   >
   > 返回的临时变量传给返回值: 调用一次复制构造函数; 
   >
   > main函数中a赋值调用复制构造函数
   >
   > 作用:
   >
   > 延长临时变量的生存时间, 避免拷贝, 提高性能

6. inline内联函数

   > 优点:
   >
   > 速度快: 内联函数同宏函数一样将在被调用处进行代码展开，**省去了参数压栈、栈帧开辟与回收，结果返回等**，从而提高程序运行速度。
   > 安全: 内联函数相比宏函数来说，在**代码展开时，会做安全检查或自动类型转换**（同普通函数），而宏定义则不会。
   > 可访问成员变量: 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。
   > 内联函数在运行时可调试，而宏定义不可以。
   >
   > 
   >
   > 缺点:
   >
   > 代码膨胀: 内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。
   >
   > 另一方面，**每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间**。
   > inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
   > 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。

   虚函数可以被inline修饰, 但虚函数想用多态的话不能inline

7. c++的内存

   > 1. 栈：是由编译器在需要时**自动分配**，不需要时**自动清除**的变量存储区。通常存放**局部变量、函数参数**等。
   >
   > 2. 堆：是由**new**分配的内存块，**由程序员释放**（编译器不管），一般一个new与一个delete对应，一个new[]与一个delete[]对应。如果程序员没有释放掉, 资源将由操作系统**在程序结束后自动回收**。
   >
   > 3. 自由存储区：是由**malloc**等分配的内存块，和堆十分相似，用**free**来释放。
   >
   > 4. **全局/静态**存储区：全局变量和静态变量被分配到同一块内存中
   >
   > 5. **常量**存储区：这是一块特殊存储区，里边存放常量，不允许修改。
   >
   > （注意：堆和自由存储区其实不过是同一块区域，new底层实现代码中调用了malloc，new可以看成是malloc智能化的高级版本）

8. 内存中堆和栈的区别

   >1. 分配方式：
   >   1. 堆都是动态分配（没有静态分配的堆）;
   >   2. 栈有静态分配和动态分配，静态分配由编译器完成（如局部变量分配）, 动态分配由alloca函数分配, 但栈的动态分配的资源由编译器进行释放，无需程序员实现。
   >
   >2. 生长方向
   >   1. 堆向上增长; 栈向下

9. new和malloc

   > 1. 参数:
   > 2. malloc是从**堆上**动态分配内存，new是从**自由存储区**为对象动态分配内存。 
   > 3. new申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。
   >    2. malloc则需显式指出内存的尺寸。
   > 4. 功能
   >    1. new：分配内存 和 调用构造函数; delete：调用析构函数 和 释放内存
   >    2. malloc和free: 只是分配和释放内存
   >  5. 返回:
   >     1. new内存分配失败时，会抛出bad_alloc异常;
   >     2. malloc分配内存失败时返回NULL。
   >

10. 内存分配和管理 malloc、calloc、realloc、alloca

   > malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。
   > calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位都初始化为 0。
   > realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。
   > alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。

2. new、delete

   > new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。
   > delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。
   > new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。

12. allocator类

13. 数组与链表

   > 数组
   >
   > 元素在内存中连续存放，每个元素占用内存相同，可通过下标迅速访问数组中任何元素; 
   >
   > 增删开销大
   >
   > **(静态)数组从栈中分配空间**, 对于程序员方便快速,但自由度小。 
   >
   > 
   >
   > 链表
   >
   > 通过指针连接起来
   >
   > 需要时可以**用new分配内存空间，不需要时用delete将已分配的空间释放**
   >
   > 链表从堆中分配空间, 自由度大但申请管理比较麻烦. 

14. 函数调用的过程

    > 整个函数的调用总结起来就干了四件事情：
    >
    > 第一：将调用方的栈底地址入栈。====》push  ebp
    >
    > 第二：让原本指向调用方**栈底的ebp指向当前函数的栈底**。====》mov   ebp,esp
    >
    > 第三：给当前函数**开辟栈帧** (通过**栈底指针偏移将局部变量压入栈桢空间**)====>sub   esp,44h
    >
    > 第四：对开辟的栈帧进行初始化。初始化的大小不一定。====>rep   stos  
    >
    > 
    >
    > 例子:
    >
    >     void func(int m, int n) {
    >     int a, b;
    >     a = m;
    >     b = n;
    >     }
    >     main() {
    >     ...
    >     func(m, n);
    >     L:  下一条语句;
    >     }
    >
    > main调用func前:
    >
    > ```
    > ebp //main函数栈帧底部
    > ...
    > esp	//当前栈顶
    > ```
    >
    > 调用func时(写成汇编):
    >
    > ```
    > push m
    > push n; 两个参数压入栈
    > call func; 调用func，将返回地址（实际上是当前PC值的下一个值, 即L）填入栈，并跳转到func
    > ```
    >
    > 当成功跳转到func函数中时，func函数的栈帧就已经形成了，但是形成新的栈帧之前，必须要重新记录当前栈帧的栈底指针ebp，保存和切换ebp
    >
    > ```
    > push ebp; 
    > /*函数调用之所以能够返回，单靠保持返回地址是不够的，这一步压栈动作很重要，因为我们要标记函数调用者栈帧的帧底，这样才能找出保存了的返回地址，栈顶是不用保存的，因为上一个栈帧的顶部讲会是func的栈帧底部。（两栈帧相邻的）*/
    > mov ebp, esp; 上一栈帧的顶部，就是这个栈帧的底部
    > sub esp, 8   ;  int a, b 这里声明了两个int，所以esp减小8个字节来为a,b分配空间
    > mov dword ptr [esp+4], [ebp+12];   a=m
    > mov dword ptr [esp], [ebp+8]; b=n 
    > ```
    >
    > 当从func函数返回时:
    >
    > ```
    > esp移动到栈帧底部（即释放自动变量）
    > 上一个函数的栈帧底部指针弹出到ebp，再弹出返回地址到cs:ip上，
    > esp继续移动划过参数
    > 这样，ebp,esp就回到了调用函数前的状态，即现在恢复了原来的main的栈帧。
    > ```

15. main函数执行前做了什么

    > 1. **操作系统创建进程**后，把**控制权交给程序的入口函数**, 往往是运行时库的某个入口函数。 
    >
    > 2. 入口函数对运行库和程序运行环境进行**初始化**，包括**堆，I/O，线程，全局变量构造**等。
    > 3. 调用main函数，正式开始执行程序主体。
    > 4. 执行main完毕，返回入口函数，进行清理工作，包括全局变量析构，堆销毁，关闭I/O等，然后进行系统调用结束进程

16. volatile 不稳定的

    > 变量可被编译器未知原因修改, 每次取值都直接从内存取

17. assert

    > 断言, false则中断程序

18. "#pragma pack(n)"

    > 主要作用: 改变编译器的内存对齐方式,网络报文的处理中很重要
    >
    > 默认n=8, 可取1,2,4,8,16(字节)
    >
    > gcc默认=4, vs默认为8
    >
    > ```c++
    > #pragma pack(4)
    > class test1{
    >   char c='1';//1byte 
    >     int i;//4byte
    >     short s=2;//2byte
    > };
    > 
    > class test2 {
    >     int i;//4byte
    >     char c = '1';//1byte 
    >     short s = 2;//2byte
    > };
    > sizeof(test1)为12; sizeof(test2)为8
    >   
    > // 因为c(占用1,对齐为4)即 c(1 0 0 0) i(1 1 1 1) s(1 1) 类本身对齐(0 0)
    > // c直接分配1字节, 然后i需要4, 只有3字节,不够,所以此时才空3格, 重新分配4字节
    > ```

19. 内存对齐

    > C++空类的内存大小为1字节
    >
    > 非空类的大小与类中非静态成员变量和虚函数表的多少有关。
    >
    > 而类中非静态成员变量的大小与编译器内存对齐的设置有关。
    >
    > 成员变量在类中的内存存储并不一定是连续的。它是按照编译器的设置，按照内存块来存储的，这个内存块大小的取值，就是内存对齐。

20. 大端与小端模式

    > 网络字节序: 大端
    >
    > 主机: 大端或小端 看机型(x86(intel, ARM为小端))
    >
    > 文件: PS, JPEG(大端) ; BMP, GIF(小端)
    >
    > 大端、小端的判断:
    >
    > ```c++
    > int i = 0x12345678;
    > if (*((char*)&i) == 0x12) // 第一个字节地址(取址)的内容转为字符数组(char*强制转化)查看(*)
    > 	cout << "大端" << endl;
    > else	
    > 	cout << "小端" << endl;
    > ```

21. extern “C”

   > extern "C" 的作用是让 C++ 编译器将 extern "C" 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。
   >
   > 和#ifdef #endif一起使用

22. 多态分类及实现

    > 重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载
    > 子类型多态（Subtype Polymorphism，运行期）：虚函数
    > 参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板
    > 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换

23. 虚函数

    > 1. 虚函数代价:
    >    1. 虚函数表(当然不用占用类的内存空间)
    >    2. 类的对象需要维护一个虚表指针(4字节)
    >    3. 虚函数不能内联
    > 2. 不能是虚函数的:
    >
    >    1. 普通函数（非类成员函数）不能是虚函数;
    >    2. 友元函数: 不属于类的
    >    3. 静态函数（static）不能是虚函数**, 因为静态函数没有this指针, 无法访问对象的虚表指**
    >    4. **构造函数不能是虚函数（因为在调用构造函数时，**虚表指针并没有在对象的内存空间**中，必须要构造函数调用完成后才会形成虚表指针）
    >    5. 内联函数不能是表现多态性时的虚函数, 内敛函数在编译时进行函数题替换, 虚函数表现多态时在运行时决定

24. 虚函数表(虚表) 和 虚函数表指针

    > 为实现C++的多态，C++使用了一种**动态绑定**的技术, 其核心是虚函数表
    >
    > 每个包含了虚函数的类都包含一个虚表
    >
    > **虚表就是一个指针数组**, 里面的指针指向该类虚函数的地址
    >
    > **虚表是属于类不是对象的**, 同类的各对象的虚表指针指向同个虚表  
    >
    > 
    >
    > 继承:
    >
    > A类是基类, B继承A
    >
    > A的虚表指向vfunc1() 和 vfunc2(), B如果重写vfunc2(), 则B的虚表指向vfunc1() 和 B::vfunc2()
    >
    > 普通函数(非虚函数)不在虚表中
    >
    > 
    >
    > A* p指向B对象, 然后用p调用vfunc1()的过程:
    >
    > 程序在执行p->vfunc1()时，会发现p是个指针，且调用的函数是虚函数，便会进行以下的步骤:
    > 首先，根据虚表指针p->vptr来**访问对象bObject对应的虚表**。虽然指针p是基类A*类型，但是vptr也是基类的一部分，所以可以通过p->vptr可以访问到对象对应的虚表。 
    > 然后，在虚表中查找所调用的函数对应的条目。由于**虚表在编译阶段就可以构造出来了**，所以可以根据所调用的函数**定位到虚表中的对应条目**。对于 p->vfunc1()的调用，B vtbl的第一项即是vfunc1对应的条目。 
    > 最后，根据虚表中找到的函数指针，调用函数。从图3可以看到，B vtbl的第一项指向B::vfunc1()，所以 p->vfunc1()实质会调用B::vfunc1()函数。
    >
    > 实现了多态(虚函数和对象(指针)的动态绑定)

25. 虚析构函数(结合“虚函数表 和 虚表指针”回答)

   > 虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。

26. 纯虚函数

    > `virtual int A() = 0;`
    >
    > 纯虚函数关注的是接口的统一性，实现由子类完成
    >
    > 带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。

27. 虚继承

    > 虚继承是与虚函数完全无关的一个概念
    >
    > 虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性(子类中存在多份拷贝)）。
    >
    > 一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。
    >
    > vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。

28. 抽象类、接口类、聚合类

    > 抽象类：含有纯虚函数的类;
    >
    > 接口类：仅含有纯虚函数的抽象类;
    >
    > 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。
    >
    > 满足如下特点：
    > 	所有成员都是 public
    > 	没有定义任何构造函数
    > 	没有类内初始化
    > 	没有基类，也没有 virtual 函数

29. 智能指针

    > 不恰当处理指针就会带来许多问题, 比如: 指针所指向对象的生命周期, 挂起引用（dangling references）, 内存泄露这些问题。
    >
    > 挂起引用: 一块内存被多个指针引用，但其中的一个指针释放且其余的指针并不知道，这样的情况下，就发生了
    >
    > 内存泄漏: 从堆中申请了内存后不释放回去
    >
    > 
    >
    > C++11以前的智能指针: auto_ptr, 离开作用域会自动释放所致内存地址
    >
    > 缺点: 
    >
    > 1. auto_ptr赋值给另一个auto_ptr, 所有权转移之后, 原来的可能变成野指针
    > 2. 不能指向一组对象, 比如跟new[]一起用
    >
    > 
    >
    > C++11的智能指针: share_ptr, unique_ptr, weak_ptr
    >
    > share_ptr: 多个指针可以同时指向一个对象，当最后一个shared_ptr离开作用域时，内存才会自动释放。
    >
    > unique_ptr: 采用独占式拥有，确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。
    >
    > weak_ptr: 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty) 

30. 强制转换

    > static_cast(非多态类型转换),
    >
    > dynamic_cast(多态类型转换, 转换时会检查(安全),), 
    >
    > const_cast, 
    >
    > reinterpret_cast(重新解释) 

31. c++11新特性

    > 1. nullptr: 可以被转换成任意其它的指针类型
    > 2. for(auto i : arr )
    > 3. auto, decltype表示智能类型
    > 4. 智能指针(share_ptr, unique_ptr, weak_ptr)
    > 5. unordered_map, unordered_set
    > 6. lambda表达式
    > 7. std::thread

32. auto和decltype(type)

    >  都是C++11新增的关键字，都用于自动类型推导
    >
    > auto会去掉引用, decltype会保留引用;
    >
    > decltype可以不初始化, auto必须初始化;

33. stl中的vector和array

    > 区别:
    >
    > array 是静态空间，一旦配置了就不能改变，vector 是动态数组。在 ***堆上*** 分配空间
    >
    > 
    >
    > vector:
    >
    > capacity: end - first; size: last - first
    >
    > `reserve（Count）`: 对应capacity, 预留空间, 防止二次分配
    >
    > `resize(Count)`:对应size
    >
    > capacity扩容按不同库可能会扩大一半或一倍
    >
    > 创建时会配置比其所容纳的元素所需更多的内存, 避免二次分配
    >
    > 扩容: 弃用现有, 申请更大, 移动旧数据, 释放原内存

34. stl中的list

    > STL 中的list 底层是一个双向链表，而且是一个环状双向链表
    >
    > 需要经常添加删除大对象, 可使用 list；
    > 保存的对象不大，构造与析构操作不复杂，那么可以使用 vector 代替。
    > list<指针> 是性能最低的做法，这种情况下还是使用 vector<指针> 好，因为指针没有构造与析构，也不占用很大内存

35. stl中的priority_queue

    > 以vector实现的完全二叉树
    >
    > 堆的要点:
    >
    > 1. 建堆: 左右子树为堆的前提, 大的与当前节点交换, 然后siftdown操作
    > 2. 插入: 放后面, 直接向上交换, 直到停止, 不用siftdown
    > 3. 删除: 把最后一个(完全二叉树的最后一个)置换道要删的, 然后siftdown

36. stl中的set和multi_set

    > 底层为红黑树RB-Tree, 故查到时间复杂度O(log n), 值即键值, 值自动排序

37. stl中的map和multi_map

    > 底层为红黑树RB-Tree, 故查到时间复杂度O(log n)

38. stl中的unordered_map

    > hash_map是非标准库, c++11标准化为了防止误用新的, 将新加的哈希表命名为unordered_map
    >
    > 底层为hash map实现, 相比hash_map可以用string和其他一些复杂类型作为键值

39. lambda表达式

40. 动态内存

41. typeid

42. 强制类型转化cast

    > dynamic_cast: 类类型指针
    >
    > static_cast: 有关联的类指针 或者 隐式转换(int, float)
    >
    > const_cast
    >
    > reinterpret_cast可以适用于任何类型指针之间的转换, 但不安全

43. Linux指令

    > 1. 通配符
    >
    >    “？”可替代单个字符。 ·“*”可替代任意多个字符。 ·方括号“[charset]”可替代 charset 集中的任何单个字符，如[a-z]，[abABC]
    >
    > 2. ipcs: 进程间通信
    >
    > 3. ps
    >
    > 4. top
    >
    > 5. netstat
    >
    > 6. kill
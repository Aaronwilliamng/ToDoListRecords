# 面试自问自答 - c++



1. const

   > 作用:
   >
   > 1. 修饰变量，说明该变量不可以被改变；
   > 2. 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；
   > 3. 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；
   > 4. **修饰成员函数，说明该成员函数内不能修改成员变量**。

2. static

   > 作用:
   >
   > 1. 修饰普通变量，修改变量的存储区域和生命周期，使**变量存储在静态区，在 main 函数运行前就分配了空间**，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
   > 2. 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。
   > 3. 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。
   > 4. 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 **static 函数内不能访问非静态成员**。

3. this指针

   > this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。
   > 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。
   > this 指针被隐含地声明为: ClassName *const this，这意味着**不能给 this 指针赋值**；*但可以修改指针指向的地址, (指针的本质是一个地址(这个不可修改), 它存的值(*this)也是一个地址,这个可以修改,即修改指向)
   >
   > this 并不是一个常规变量，而是个右值，所以**不能取得 this 的地址**（不能 &this）。
   >
   > *在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；
   >
   > 在以下场景中，经常需要显式引用 this 指针：
   > 为实现对象的链式引用；
   > 为避免对同一对象进行赋值操作；
   > 在实现一些数据结构时，如 list

4. inline内联函数

   > 优点:
   >
   > 速度快: 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。
   > 安全: 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。
   > 可访问成员变量: 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。
   > 内联函数在运行时可调试，而宏定义不可以。
   >
   > 
   >
   > 缺点:
   >
   > 代码膨胀: 内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
   > inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
   > 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。

   虚函数可以被inline修饰, 但虚函数想用多态的话不能inline

5. volatile 不稳定的

   > 变量可被编译器未知原因修改, 每次取值都直接从内存取

6. assert

   > 断言, false则中断程序

7. "#pragma pack(n)"

   > 主要作用: 改变编译器的内存对齐方式,网络报文的处理中很重要
   >
   > 默认n=8, 可取1,2,4,8,16(字节)

8. extern “C”

   > extern "C" 的作用是让 C++ 编译器将 extern "C" 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。
   >
   > 和#ifdef #endif一起使用

9. 多态分类及实现

   > 重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载
   > 子类型多态（Subtype Polymorphism，运行期）：虚函数
   > 参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板
   > 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换

10. 虚函数

    > 普通函数（非类成员函数）不能是虚函数;
    > 静态函数（static）不能是虚函数;
    > 构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）;
    > 内联函数不能是表现多态性时的虚函数

11. 虚析构函数
	
	> 虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。
	
12. 纯虚函数

    > `virtual int A() = 0;`
    >
    > 纯虚函数关注的是接口的统一性，实现由子类完成
    >
    > 带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。

13. 虚继承

    > 虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。
    >
    > 一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。
    >
    > vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。

14. 抽象类、接口类、聚合类

    > 抽象类：含有纯虚函数的类;
    >
    > 接口类：仅含有纯虚函数的抽象类;
    >
    > 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。
    >
    > 满足如下特点：
    > 	所有成员都是 public
    > 	没有定义任何构造函数
    > 	没有类内初始化
    > 	没有基类，也没有 virtual 函数

15. 内存分配和管理 malloc、calloc、realloc、alloca

    > malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。
    > calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位都初始化为 0。
    > realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。
    > alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。

16. new、delete

    > new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。
    > delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。
    > new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。

17. 智能指针

    > 不恰当处理指针就会带来许多问题, 比如: 指针所指向对象的生命周期, 挂起引用（dangling references）, 内存泄露这些问题。
    >
    > 挂起引用: 一块内存被多个指针引用，但其中的一个指针释放且其余的指针并不知道，这样的情况下，就发生了
    >
    > 内存泄漏: 从堆中申请了内存后不释放回去
    >
    > 
    >
    > C++11以前的智能指针: auto_ptr, 离开作用域会自动释放所致内存地址
    >
    > 缺点: 
    >
    > 1. auto_ptr赋值给另一个auto_ptr, 所有权转移之后, 原来的可能变成野指针
    > 2. 不能指向一组对象, 比如跟new[]一起用
    >
    > 
    >
    > C++11的智能指针: share_ptr, unique_ptr, weak_ptr
    >
    > share_ptr: 多个指针可以同时指向一个对象，当最后一个shared_ptr离开作用域时，内存才会自动释放。
    >
    > unique_ptr: 采用独占式拥有，确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。
    >
    > weak_ptr: 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）

18. 强制转换

    > static_cast(非多态类型转换), dynamic_cast(多态类型转换, 转换时会检查(安全),), const_cast, reinterpret_cast(重新解释) 
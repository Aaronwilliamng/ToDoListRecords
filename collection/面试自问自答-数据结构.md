# 面试自问自答-数据结构



2. 哈希表

   > 散列函数: 
   >
   > 1. 直接地址法: H(key) = key或H(key) = a·key + b
   >
   > 2. 取余
   >
   > 3. 平方+右移: (value*value)>>28
   >
   > 4. 斐波那契: 16位整数, 乘数是40503; 32位, 乘数是2654435769; 64位乘数是11400714819323198485
   >
   >    (value*乘数)>>28
   >
   > 5. 平方取中法
   >
   > 
   >
   > 解决冲突:
   >
   > 1. 开放寻址(删除不能直接删, 会截断探测路径, 需要设置一个特殊标志) **[数据量小可选用]**
   >    1. 线性 (聚集现象: 哈希表 不要超过数据容量的一半，最多不超过2/3, 超过时应该扩展数组(如2倍)) 
   >    2. 平方(二次探测): i(第几次探测)的平方, 这样即使冲突,只要i不同,下一次探查也会分开
   >    3. 再哈希(re-hashing): 不同的哈希函数
   > 2. 双散列函数(不容易聚集, 但计算时间 长)
   > 3.  拉链法(比开放寻址 空间利用率更高 更灵活(可以用红黑树等结构代替链表) 无堆积现象 ) **[数据量大]**

3. 二叉树

   > 平衡二叉树（AVL树）：| 左子树树高 - 右子树树高 | <= 1
   >
   > 最小失衡树的调整：(平衡二叉树插入新结点导致失衡的子树)
   > 	LL型：根的左孩子右旋
   > 	RR型：根的右孩子左旋
   > 	LR型：根的左孩子左旋，再右旋
   > 	RL型：右孩子的左子树，先右旋，再左旋
   >
   > 
   >
   > 二叉树的插入:
   >
   > 先查找, 再判断插入到左还是右节点
   >
   > 
   >
   > 二叉树的删除:
   >
   > 1. 只有左子树: 该节点的父节点指向该节点的左节点
   > 2. 只有右子树
   > 3. 根节点: 指向左子树, 删除root
   > 4. 有左、右子树: 先找到该节点右子树的最左节点, 跟该节点交换, 删除

4. 搜索结构有哪些? (比如搜索树, 哈希, 顺序表(顺序, 二分))

5. 红黑树

   > [面试 红黑树 问题]https://blog.csdn.net/varyall/article/details/82634162
   >
   > 简介: 红黑树并不是完美平衡树(AVL是), RB-Tree是黑色完美平衡;
   >
   > 1. 红黑树的统计性能为什么比AVL好?
   >    1. 插入引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度。
   >    2. AVL的平衡要求更高, 所以大量插入, 删除操作时, AVL的平衡操作更多, 但AVL的搜索性能较高
   >
   > 2. 数据结构: 左右指针, key, value, color
   >
   > 3. 性质:
   >    1. 节点是红色或黑色
   >    2. 根节点是黑色
   >    3. 每个叶节点是黑色的。
   >    4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
   >    5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。
   >
   > 4. 操作复杂度: 在最坏情况, 插入, 删除, 搜索都O(log n)
   > 5. 红黑树和hash怎么选择?
   >    1. O(log n)不一定比O(1)大
   >    2. hash函数的额外耗时
   >    3. hash构造慢
   >    4. hash内存消耗大
   > 6. 调整平衡: 插入可能引发双红修正, 删除可能引发双黑修正

6. 跳表

   > 优势(redis用的是跳表): 实现简单很多, (相比于红黑树、平衡二叉树，跳表), 且查找、插入、删除时间复杂度都是O(logN)
   >
   > 头部、尾部是哨兵占位符
   >
   > 缺点: 内存占用大, 每个节点用的指针比较多(4个); 

   

   👍:  [面试官问你B树和B+树，就把这篇文章丢给他]https://www.jianshu.com/p/7a2017e830a0

7. B树 

   > 1. b树需要指定阶数m:
   >
   >    根节点的关键字数量范围: 1 <= k <= m-1, 非根节点的关键字数量范围：m/2 <= k <= m-1。
   >
   > 2. b树优点: 节点子女可以从几十到几千, 高度比红黑树小
   >
   > 3. b树插入操作: 直接删 找最右子树最小代替 再调整(找兄弟借 或者 找父借和兄弟合并 )
   >
   > 4. 每个结点保存指向真实数据的指针, 相比B+树的内部结点并没有指向关键字具体信息的指针，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多

8. B+树

   > 1. 特点: 
   >    1. 内部结点和叶子结点。内部节点就是非叶子节点，内部节点只存储索引，数据都在叶子节点。
   >    2. 每个叶子结点都存有相邻叶子结点的指针
   >2. 使用场景: 大部分文件系统、数据库系统都采用B树和B+树作为索引结构
   > 3. 优点:
   >   1. 内部节点小, 盘块可以容纳更多内部节点, 一次读入内存的关键字越多, IO读写次数就降低
   >    2. 叶子结点链表相连: 符合基于范围查找
   >    3. 查询性能是稳定
   > 4. 插入: 超过m-1就分裂 中间的做索引
   > 5. 删除: 兄弟有就借 更新索引; 兄弟不够就合并, 删除索引
   
9. Redis - 字典 dict  ( Redis底层数据结构 https://zhuanlan.zhihu.com/p/103367975)

  > 当哈希结构中放了两个短的值，此时哈希的编码方式是 **ziplist (一个经过特殊编码的双向链表);**
  >
  > 而当插入一个较长的值，哈希的编码方式成为了 **hashtable;**
  >
  > 
  >
  > Redis的哈希函数: siphash, Murmurhash2 (这两个随机分布性能较好)
  >
  > Redis哈希冲突解决: **链地址法**
  >
  > 哈希表过于稀疏/拥挤: **扩容/缩容 (需要rehash)** 
  >
  >  	1. 当 Redis 没有进行 BGSAVE 相关操作(没有子进程存在时)，且 负载因子>1的时候进行扩容 (BGSAVE存在子进程)
  >  	2. 当负载因子>5的时候，强行进行扩容
  >  	3. 当负载因子<0.1的时候，进行缩容 
  >
  > rehash过程采用**渐进式rehash**: 
  >
  > ​	采用渐进式**rehash**,设置一个rehashIndex
  >
  > ​	存在两张table(ht[0] 和 ht[1]), 先为ht[1]分配空间
  >
  > ​	每次进行增删改操作之后 插入一次rehash操作,rehashIndex递增, 全部结束时设-1
  >
  > ​	redis的定时函数也加入rehash操作, 这样服务器空闲时就能一直rehash
  >
  > ​	rehash期间, “增”只在ht[1]进行; “删/改”先去ht[0]操作, 没有才去ht[1]
  >
  > 

10. 排序算法

   > 快排不稳定; 归并稳定
   >
   > 桶排序: O(n), 牺牲空间换时间, 每个桶需要排序
   >
   > 选择, 插入, 冒泡
   >
   > 归并, 
   >
   > 快排, 
   >
   > 堆排序, 
   >
   > 桶排序
   >
   > 希尔

11. 查找算法

   > 顺序, 二分, 插值, 斐波那契, 哈希, 树(二叉, 2-3, 红黑, B, B+)

12. 栈的应用

   > 逆序输出; 括号匹配; 递归
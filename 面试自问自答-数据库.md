# 面试自问自答-数据库

[常见面试题及答案CSDN]https://blog.csdn.net/qq_22222499/article/details/79060495

1. 数据库常用操作

   > - `CREATE DATABASE db_name;`
   >
   > - `DROP DATABASE db_name;`: 删除数据库
   > - `use db_name;`
   >
   > 
   >
   > - `CREATE TABLE table_name (column_name column_type);`
   >
   >   e.g.
   >
   > 	```mysql
   > 	CREATE TABLE IF NOT EXISTS `runoob_tbl`(
   > 	   `runoob_id` INT UNSIGNED AUTO_INCREMENT,//AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1
   > 	   `runoob_title` VARCHAR(100) NOT NULL, //字段属性为NOT NULL, 输入该字段数据为NULL就会报错
   >  	  `runoob_author` VARCHAR(40) NOT NULL,
   >   	 `submission_date` DATE,
   >   	 PRIMARY KEY ( `runoob_id` ) //PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔
   > 	ENGINE=InnoDB DEFAULT CHARSET=utf8; //ENGINE 设置存储引擎，CHARSET 设置编码
   > 	```
   >
   > - `DROP TABLE table_name ;`
   >
   > - ```mysql
   >   插入数据
   >   INSERT INTO table_name ( field1, field2,...fieldN )
   >                          VALUES
   >                          ( value1, value2,...valueN );
   >   ```
   >
   > - ```mysql
   >   查询数据
   >   SELECT column_name,column_name
   >   FROM table_name
   >   [WHERE Clause]
   >   [LIMIT N]
   >   ```
   >
   > - ````mysql
   >   更新数据
   >   UPDATE table_name SET field1=new-value1, field2=new-value2
   >   [WHERE Clause]
   >   ````
   >
   > - `DELETE FROM table_name [WHERE Clause]`
   >
   > - LIKE与%一起使用 (含有某字段):`SELECT * from runoob_tbl  WHERE runoob_author LIKE '%COM';`
   >
   > - ```mysql
   >   ORDER BY 排序:
   >   SELECT field1, field2,...fieldN FROM table_name1, table_name2...
   >   ORDER BY field1 [ASC [DESC][默认 ASC]], [field2...] [ASC [DESC][默认 ASC]]
   >   // ASC升序, DESC降序
   >   ```
   >
   > - ```mysql
   >   GROUP BY:
   >   SELECT column_name, function(column_name)
   >   FROM table_name
   >   WHERE column_name operator value
   >   GROUP BY column_name;
   >   ```
   >
   > - 联合表查询
   >
   > 		`INNER JOIN`（内连接,或等值连接）：获取两个表中字段匹配关系的记录。
   >   `LEFT JOIN`（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。
   >   `RIGHT JOIN`（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。
   >   
   >   ```mysql
   >   SELECT a.runoob_id, a.runoob_author, b.runoob_count 
   >   FROM runoob_tbl a INNER JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;
   >   ```
   >   
   >   

   > create database Student;  创建一个名字为Student库：
   >
   > 用以下地命令来查看创建的数据库是否成功：show databases;
   >
   > 进入数据库：use Student;
   >
   > 用下面的命令来查看该数据库中的表：show tables;
   >
   >
   > 用下面的命令来创建表：create table User_Info(id int , pwd int , primary key(id));
   >
   > 用下面的命令来检查表的创建是否成功：show tables;
   >
   >
   > 可以用下面的明亮来查看该表中的属性的性质：describe User_Info;
   >
   > 
   >
   > 可以用下面的命令来向该表中添加属性：
   >
   > 1、创建一个新表  ：   create  table 表名  (字段名1  数据类型  ，字段名2  数据类型，。。。)；如果要设置主键或非空，则在数据类型后面加上 primary key(主键)  或  not null 
   > 2、查询数据表：  select  *  from 表名；
   > 3、添加记录 ：   insert   into  表名 （字段1，字段2，...）  values('值1'，‘值2’，...);
   > 4、删除记录 ：   delete  from  表名  where 查询条件；
   > 5、更新 记录：   update  表名   set  字段=新值   where  条件；

2. 数据库数据类型

   > INT, TINYINT, SMALLINT, MEDIUMINT, BIGINT
   >
   > FLOAT, DOUBLE, DECIMAL
   >
   > DATE, TIME, DATETIME, YEAR, TIMESTAMP
   >
   > CHAR(固定长), VARCHAR(可变长), TEXT(长文本), BLOB(二进制长文本)

3. 三个范式

   > 首先要明确的是：满足着第三范式，那么就一定满足第二范式、满足着第二范式就一定满足第一范式
   >
   > 
   >
   > 第一范式：字段是最小的的单元不可再分
   >
   > 学生信息组成学生信息表，有年龄、性别、学号等信息组成。这些字段都不可再分，所以它是满足第一范式的
   >
   > 
   >
   >
   > 第二范式：满足第一范式,表中的字段必须完全依赖于全部主键而非部分主键。
   >
   > 其他字段组成的这行记录和主键表示的是同一个东西，而主键是唯一的，它们只需要依赖于主键，也就成了唯一的
   > 学号为1024的同学，姓名为Java3y，年龄是22岁。姓名和年龄字段都依赖着学号主键。
   >
   > 
   >
   >
   > 第三范式：满足第二范式，非主键外的所有字段必须互不依赖
   >
   > 就是数据只在一个地方存储，不重复出现在多张表中，可以认为就是消除传递依赖
   > 比如，我们大学分了很多系（中文系、英语系、计算机系……），这个系别管理表信息有以下字段组成：系编号，系主任，系简介，系架构。那我们能不能在学生信息表添加系编号，系主任，系简介，系架构字段呢？不行的，因为这样就冗余了，非主键外的字段形成了依赖关系(依赖到学生信息表了)！正确的做法是：学生表就只能增加一个系编号字段。

4. DROP, DELETE, TRUNCATE的区别

   >不再需要一张表的时候，用drop
   >
   >想删除部分数据行时候，用delete，并且带上where子句
   >
   >保留表而删除所有数据的时候用truncate
   >
   >DELETE: 可回滚; 可带where; 表结构在，表内容要看where执行的情况; 删除速度慢,需要逐行删除

5. 数据库的索引

   > 索引加快数据库的检索速度; 但是, 索引降低了插入、删除、修改等维护任务的速度

6. 联合索引: left\right join, inner join, cross join

   > inner: 交集
   >
   > cross join: 笛卡尔积, A表有4条记录, B有3条, 这cross join有12条

7. ACID(事务管理) session事务: 

   > https://www.jianshu.com/p/2c30d1fe5c4e
   >
   > 1. 事务4个特性
   >
   >    1. 原子性: 事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。
   >    2. 一致性: 数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。
   >    3. 隔离性: 一个事务所做的修改在最终提交以前，对其它事务是不可见的。
   >    4. 持久性: 一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。可以通过数据库备份和恢复来实现，在系统发生崩溃时，使用备份的数据库进行数据恢复。
   >
   > 2. 数据库定义了4个隔离级别：
   >
   >    串行读【可避免脏读，不可重复读，虚读】读用读锁，写用写锁 [通过加表锁来解决串行化]
   >    可重复读(默认)【可避免脏读，不可重复读, 不能解决幻读/虚读】 [读的一瞬间加锁，但是一直到事务结束才释放锁]
   >    提交读【可避免脏读, 但不能避免不可重复读】[事务**读数据的瞬间会加行级共享锁**，*一旦读完该行，立即释放该行级共享锁*；而**写数据的瞬间会加行级排它锁**，直到事务结束]
   >    未提交读【级别最低】事务中的修改，即使没有提交，对其它事务也是可见的。这样会提高性能，但是会导致脏读问题。[因为事务读数据时不会加锁，**写数据时会有行级共享锁**]

8. 并发一致性问题(就是上面脏读, 不可重复读等)

   > 1. 脏读数据：T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。
   > 2. 不可重复读：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。
   > 3. 幻读：T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。

9. 悲观锁、乐观锁

   > 确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性，乐观锁和悲观锁是并发控制主要采用的技术手段。
   >
   > 
   >
   > 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作
   >
   > (表锁, 行锁, 读锁, 写锁, 排它锁均属于悲观锁)
   >
   > 在查询完数据的时候就把事务锁起来，直到提交事务
   > 实现方式：使用数据库中的锁机制
   >
   > 好处: 保证不会发生并发执行，数据操作效率高; 
   >
   > 坏处: 影响并发量, 有可能发生死锁
   >
   > 
   >
   >
   > 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。
   >
   > 在修改数据的时候把事务锁起来，通过version的方式来进行锁定
   > 实现方式：使用version版本或者时间戳, 持有数据更改的版本号, **只有数据在提交的时候校验版本号, 如果冲突则回滚事务, 不冲突则提交数据, 并自增version**。
   >
   > 
   >
   > 排他锁: 

10. 主键, 超键, 候选键, 外键

   > 学生信息（学号 身份证号 性别 年龄 身高 体重 宿舍号）和 宿舍信息（宿舍号 楼号）
   >
   > 超键：只要含有“学号”或者“身份证号”两个属性的集合就叫超键，例如R1（学号 性别）、R2（身份证号 身高）、R3（学号 身份证号）等等都可以称为超键
   >
   > 候选键：不含有多余的属性的超键，比如（学号）、（身份证号）都是候选键，又比如R1中学号这一个属性就可以唯一标识元组了，而有没有性别这一属性对是否唯一标识元组没有任何的影响！
   >
   > 主键：就是用户从很多候选键选出来的一个键就是主键，比如你要求学号是主键，那么身份证号就不可以是主键了
   >
   > 外键：宿舍号就是学生信息表的外键

11. SQL的约束

   > NOT NULL: 用于控制字段的内容一定不能为空（NULL）。
   > UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。
   > PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。
   > FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。
   > CHECK: 用于控制字段的值范围。

12. SQL优化

    > 书写的顺序、策略会影响到SQL的性能
    >
    > 1. 最有效率的表名顺序
    >
    >    如果三个表是完全无关系的话，将记录和列名最少的表，写在最后，然后依次类推;
    >
    >    如果三个表是有关系的话，将引用最多的表，放在最后，然后依次类推。
    >
    > 2. WHERE子句中的连接顺序
    >
    >    数据库采用自右而左的顺序解析WHERE子句, 可以过滤掉最大数量记录的条件必须写在WHERE子句的之右
    >
    > 3. SELECT子句中避免使用*号
    >
    > 4. 用TRUNCATE替代DELETE
    >
    > 5. 多使用内部函数提高SQL效率
    >
    > 6. 善用索引
    >
    > 7. SQL写大写

13. Redis为什么快?(跳表/hashing)

    > 1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)；
    >
    > 2、数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；
    >
    > 3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
    >
    > 4、使用多路 I/O 复用模型，非阻塞 IO；
    >
    > 5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；

14. Innodb和MyISAM (MySQL的两个搜索引擎)

    > 1. InnoDB的B+树 **聚集索引**, 即**主键索引的叶子节点**就是数据文件，**辅助索引的叶子节点**是**主键的值**；(InnoDB表必须有主键（用户没有指定的话会自己找或生产一个主键），而Myisam可以没有)
    >
    >    MyISAM的B+树 **非聚集索引**, 主键索引和辅助索引的**叶子节点都是数据文件的地址指针**。
    >
    > 2. Innodb支持事务; myisam不支持
    >
    > 3. innodb支持外键, myisam不支持
    >
    > 4.  InnoDB支持表、行(默认)级锁; MyISAM支持表级锁
    >
    > 5. innodb不支持全文索引; myisam支持
    >
    > 
    >
    > innodb引擎的4大特性:
    >
    > 插入缓冲（insert buffer), 二次写(double write), 自适应哈希索引(ahi), 预读(read ahead)

15. 聚集索引和非聚集索引

    > 聚簇索引：索引的叶节点就是数据节点
    >
    > 非聚簇索引: 叶节点仍然是索引节点，只不过有一个指针指向对应的数据块

16. 数据库的索引

    > 1. 聚集索引
    > 2. 非聚集索引
    > 3. 哈希索引
    > 4. B+索引
    >
    > 频繁更改的数据库不建议用索引, 效率低, 更改数据时要同时更新索引

17. 为什么数据库索引用b+而不是hashmap?

    > 1. 利用**Hash需要把数据全部加载到内存中**，如果数据量大，很消耗内存; 而采用**B+树，是基于按照节点分段加载**，由此减少内存消耗。
    >2. 和业务场景有段，对于唯一查找（查找一个值），Hash确实更快，但数据库中**经常查询多条数据**，这时候由于B+数据的**有序性，与叶子节点又有链表相连**，他的查询效率会比Hash快的多。
    > 3. hash不能排序(? ordered_map呢)


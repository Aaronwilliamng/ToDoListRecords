# 面试自问自答-数据库



1. 数据库常用操作

   > - `CREATE DATABASE db_name;`
   >
   > - `DROP DATABASE db_name;`: 删除数据库
   > - `use db_name;`
   >
   > 
   >
   > - `CREATE TABLE table_name (column_name column_type);`
   >
   >   e.g.
   >
   > 	```mysql
   > 	CREATE TABLE IF NOT EXISTS `runoob_tbl`(
   > 	   `runoob_id` INT UNSIGNED AUTO_INCREMENT,//AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1
   > 	   `runoob_title` VARCHAR(100) NOT NULL, //字段属性为NOT NULL, 输入该字段数据为NULL就会报错
   >  	  `runoob_author` VARCHAR(40) NOT NULL,
   >   	 `submission_date` DATE,
   >   	 PRIMARY KEY ( `runoob_id` ) //PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔
   > 	ENGINE=InnoDB DEFAULT CHARSET=utf8; //ENGINE 设置存储引擎，CHARSET 设置编码
   > 	```
   >
   > - `DROP TABLE table_name ;`
   >
   > - ```mysql
   >   插入数据
   >   INSERT INTO table_name ( field1, field2,...fieldN )
   >                          VALUES
   >                          ( value1, value2,...valueN );
   >   ```
   >
   > - ```mysql
   >   查询数据
   >   SELECT column_name,column_name
   >   FROM table_name
   >   [WHERE Clause]
   >   [LIMIT N]
   >   ```
   >
   > - ````mysql
   >   更新数据
   >   UPDATE table_name SET field1=new-value1, field2=new-value2
   >   [WHERE Clause]
   >   ````
   >
   > - `DELETE FROM table_name [WHERE Clause]`
   >
   > - LIKE与%一起使用 (含有某字段):`SELECT * from runoob_tbl  WHERE runoob_author LIKE '%COM';`
   >
   > - ```mysql
   >   ORDER BY 排序:
   >   SELECT field1, field2,...fieldN FROM table_name1, table_name2...
   >   ORDER BY field1 [ASC [DESC][默认 ASC]], [field2...] [ASC [DESC][默认 ASC]]
   >   // ASC升序, DESC降序
   >   ```
   >
   > - ```mysql
   >   GROUP BY:
   >   SELECT column_name, function(column_name)
   >   FROM table_name
   >   WHERE column_name operator value
   >   GROUP BY column_name;
   >   ```
   >
   > - 联合表查询
   >
   > 		`INNER JOIN`（内连接,或等值连接）：获取两个表中字段匹配关系的记录。
   >   `LEFT JOIN`（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。
   >   `RIGHT JOIN`（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。
   >   
   >   ```mysql
   >   SELECT a.runoob_id, a.runoob_author, b.runoob_count 
   >   FROM runoob_tbl a INNER JOIN tcount_tbl b ON a.runoob_author = b.runoob_author;
   >   ```
   >   
   >   

   > create database Student;  创建一个名字为Student库：
   >
   > 用以下地命令来查看创建的数据库是否成功：show databases;
   >
   > 进入数据库：use Student;
   >
   > 用下面的命令来查看该数据库中的表：show tables;
   >
   >
   > 用下面的命令来创建表：create table User_Info(id int , pwd int , primary key(id));
   >
   > 用下面的命令来检查表的创建是否成功：show tables;
   >
   >
   > 可以用下面的明亮来查看该表中的属性的性质：describe User_Info;
   >
   > 
   >
   > 可以用下面的命令来向该表中添加属性：
   >
   > 1、创建一个新表  ：   create  table 表名  (字段名1  数据类型  ，字段名2  数据类型，。。。)；如果要设置主键或非空，则在数据类型后面加上 primary key(主键)  或  not null 
   > 2、查询数据表：  select  *  from 表名；
   > 3、添加记录 ：   insert   into  表名 （字段1，字段2，...）  values('值1'，‘值2’，...);
   > 4、删除记录 ：   delete  from  表名  where 查询条件；
   > 5、更新 记录：   update  表名   set  字段=新值   where  条件；

2. 数据库数据类型

   > INT, TINYINT, SMALLINT, MEDIUMINT, BIGINT
   >
   > FLOAT, DOUBLE, DECIMAL
   >
   > DATE, TIME, DATETIME, YEAR, TIMESTAMP
   >
   > CHAR(固定长), VARCHAR(可变长), TEXT(长文本), BLOB(二进制长文本)
   
3. 三个范式

   > 首先要明确的是：满足着第三范式，那么就一定满足第二范式、满足着第二范式就一定满足第一范式
   >
   > 
   >
   > 第一范式：字段是最小的的单元不可再分
   >
   > 学生信息组成学生信息表，有年龄、性别、学号等信息组成。这些字段都不可再分，所以它是满足第一范式的
   >
   > 
   >
   >
   > 第二范式：满足第一范式,表中的字段必须完全依赖于全部主键而非部分主键。
   >
   > 其他字段组成的这行记录和主键表示的是同一个东西，而主键是唯一的，它们只需要依赖于主键，也就成了唯一的
   > 学号为1024的同学，姓名为Java3y，年龄是22岁。姓名和年龄字段都依赖着学号主键。
   >
   > 
   >
   >
   > 第三范式：满足第二范式，非主键外的所有字段必须互不依赖
   >
   > 就是数据只在一个地方存储，不重复出现在多张表中，可以认为就是消除传递依赖
   > 比如，我们大学分了很多系（中文系、英语系、计算机系……），这个系别管理表信息有以下字段组成：系编号，系主任，系简介，系架构。那我们能不能在学生信息表添加系编号，系主任，系简介，系架构字段呢？不行的，因为这样就冗余了，非主键外的字段形成了依赖关系(依赖到学生信息表了)！正确的做法是：学生表就只能增加一个系编号字段。

4. DROP, DELETE, TRUNCATE的区别

   >不再需要一张表的时候，用drop
   >
   >想删除部分数据行时候，用delete，并且带上where子句
   >
   >保留表而删除所有数据的时候用truncate
   >
   >DELETE: 可回滚; 可带where; 表结构在，表内容要看where执行的情况; 删除速度慢,需要逐行删除

5. 数据库的索引

   > 索引加快数据库的检索速度; 但是, 索引降低了插入、删除、修改等维护任务的速度

6. session事务: 要么全部操作成功, 要么全部不成功

   > 数据库定义了4个隔离级别：
   >
   > Serializable【可避免脏读，不可重复读，虚读】
   > Repeatable read【可避免脏读，不可重复读】
   > Read committed【可避免脏读】
   > Read uncommitted【级别最低，什么都避免不了】

7. 悲观锁、乐观锁

   > 确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性，乐观锁和悲观锁是并发控制主要采用的技术手段。
   >
   > 
   >
   > 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作
   >
   > 在查询完数据的时候就把事务锁起来，直到提交事务
   > 实现方式：使用数据库中的锁机制
   >
   > 
   >
   >
   > 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。
   >
   > 在修改数据的时候把事务锁起来，通过version的方式来进行锁定
   > 实现方式：使用version版本或者时间戳

8. 主键, 超键, 候选键, 外键

   > 学生信息（学号 身份证号 性别 年龄 身高 体重 宿舍号）和 宿舍信息（宿舍号 楼号）
   >
   > 超键：只要含有“学号”或者“身份证号”两个属性的集合就叫超键，例如R1（学号 性别）、R2（身份证号 身高）、R3（学号 身份证号）等等都可以称为超键
   >
   > 候选键：不含有多余的属性的超键，比如（学号）、（身份证号）都是候选键，又比如R1中学号这一个属性就可以唯一标识元组了，而有没有性别这一属性对是否唯一标识元组没有任何的影响！
   >
   > 主键：就是用户从很多候选键选出来的一个键就是主键，比如你要求学号是主键，那么身份证号就不可以是主键了
   >
   > 外键：宿舍号就是学生信息表的外键

9. SQL的约束

   > NOT NULL: 用于控制字段的内容一定不能为空（NULL）。
   > UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。
   > PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。
   > FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。
   > CHECK: 用于控制字段的值范围。

10. MySQL存储引擎

   > Innodb引擎，Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。
   > MyIASM引擎(原本Mysql的默认引擎),不提供事务的支持，也不支持行级锁和外键。
   > MEMORY引擎：所有的数据都在内存中，数据的处理速度快，但是安全性不高。
   >
   > 
   >
   > 如果一个表修改要求比较高的事务处理，可以选择InnoDB; 
   >
   > 数据库中可以将查询要求比较高的表选择MyISAM存储。
   >
   > 
   >
   > Innodb和MyIASM索引结构都是B+树
   >
   > MyIASM引擎，B+树的数据结构中存储的内容实际上是实际数据的地址值。也就是说它的索引和实际数据是分开的，只不过使用索引指向了实际数据。这种索引的模式被称为非聚集索引。
   >
   > Innodb引擎的索引的数据结构也是B+树，只不过数据结构中存储的都是实际的数据，这种索引有被称为聚集索引。

11. SQL优化

    > 书写的顺序、策略会影响到SQL的性能
    >
    > 1. 最有效率的表名顺序
    >
    >    如果三个表是完全无关系的话，将记录和列名最少的表，写在最后，然后依次类推;
    >
    >    如果三个表是有关系的话，将引用最多的表，放在最后，然后依次类推。
    >
    > 2. WHERE子句中的连接顺序
    >
    >    数据库采用自右而左的顺序解析WHERE子句, 可以过滤掉最大数量记录的条件必须写在WHERE子句的之右
    >
    > 3. SELECT子句中避免使用*号
    >
    > 4. 用TRUNCATE替代DELETE
    >
    > 5. 多使用内部函数提高SQL效率
    >
    > 6. 善用索引
    >
    > 7. SQL写大写

12. Redis为什么快?

    > 1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)；
    >
    > 2、数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；
    >
    > 3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
    >
    > 4、使用多路 I/O 复用模型，非阻塞 IO；
    >
    > 5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；
    
13. Innodb和MyISAM

    > 1. InnoDB的B+树 主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；(InnoDB表必须有主键（用户没有指定的话会自己找或生产一个主键），而Myisam可以没有)
    >
    >    MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。
    >
    > 2. Innodb支持事务; myisam不支持
    >
    > 3. innodb支持外键, myisam不支持
    >
    > 4.  InnoDB支持表、行(默认)级锁; MyISAM支持表级锁
    >
    > 5. innodb不支持全文索引; myisam支持
    >
    > 
    >
    > innodb引擎的4大特性:
    >
    > 插入缓冲（insert buffer), 二次写(double write), 自适应哈希索引(ahi), 预读(read ahead)